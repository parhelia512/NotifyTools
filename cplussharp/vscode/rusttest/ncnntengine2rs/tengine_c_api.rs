/* automatically generated by rust-bindgen 0.58.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const MAX_SHAPE_DIM_NUM: u32 = 4;
pub const TENGINE_DT_FP32: u32 = 0;
pub const TENGINE_DT_FP16: u32 = 1;
pub const TENGINE_DT_INT8: u32 = 2;
pub const TENGINE_DT_UINT8: u32 = 3;
pub const TENGINE_DT_INT32: u32 = 4;
pub const TENGINE_DT_INT16: u32 = 5;
pub const TENGINE_LAYOUT_NCHW: u32 = 0;
pub const TENGINE_LAYOUT_NHWC: u32 = 1;
pub const TENSOR_TYPE_UNKNOWN: u32 = 0;
pub const TENSOR_TYPE_VAR: u32 = 1;
pub const TENSOR_TYPE_CONST: u32 = 2;
pub const TENSOR_TYPE_INPUT: u32 = 3;
pub const TENSOR_TYPE_DEP: u32 = 4;
pub const TENGINE_CLUSTER_ALL: u32 = 0;
pub const TENGINE_CLUSTER_BIG: u32 = 1;
pub const TENGINE_CLUSTER_MEDIUM: u32 = 2;
pub const TENGINE_CLUSTER_LITTLE: u32 = 3;
pub const TENGINE_MODE_FP32: u32 = 0;
pub const TENGINE_MODE_FP16: u32 = 1;
pub const TENGINE_MODE_HYBRID_INT8: u32 = 2;
pub const TENGINE_MODE_UINT8: u32 = 3;
pub const TENGINE_MODE_INT8: u32 = 4;
pub const NODE_DUMP_ACTION_DISABLE: u32 = 0;
pub const NODE_DUMP_ACTION_ENABLE: u32 = 1;
pub const NODE_DUMP_ACTION_START: u32 = 2;
pub const NODE_DUMP_ACTION_STOP: u32 = 3;
pub const NODE_DUMP_ACTION_GET: u32 = 4;
pub const GRAPH_PERF_STAT_DISABLE: u32 = 0;
pub const GRAPH_PERF_STAT_ENABLE: u32 = 1;
pub const GRAPH_PERF_STAT_STOP: u32 = 2;
pub const GRAPH_PERF_STAT_START: u32 = 3;
pub const GRAPH_PERF_STAT_RESET: u32 = 4;
pub const GRAPH_PERF_STAT_GET: u32 = 5;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub const log_level_LOG_EMERG: log_level = 0;
pub const log_level_LOG_ALERT: log_level = 1;
pub const log_level_LOG_CRIT: log_level = 2;
pub const log_level_LOG_ERR: log_level = 3;
pub const log_level_LOG_WARNING: log_level = 4;
pub const log_level_LOG_NOTICE: log_level = 5;
pub const log_level_LOG_INFO: log_level = 6;
pub const log_level_LOG_DEBUG: log_level = 7;
pub type log_level = ::std::os::raw::c_uint;
pub const graph_exec_event_GRAPH_EXEC_START: graph_exec_event = 0;
pub const graph_exec_event_GRAPH_EXEC_SUSPEND: graph_exec_event = 1;
pub const graph_exec_event_GRAPH_EXEC_RESUME: graph_exec_event = 2;
pub const graph_exec_event_GRAPH_EXEC_ABORT: graph_exec_event = 3;
pub const graph_exec_event_GRAPH_EXEC_DONE: graph_exec_event = 4;
pub type graph_exec_event = ::std::os::raw::c_uint;
pub const graph_exec_stat_GRAPH_STAT_CREATED: graph_exec_stat = 0;
pub const graph_exec_stat_GRAPH_STAT_READY: graph_exec_stat = 1;
pub const graph_exec_stat_GRAPH_STAT_RUNNING: graph_exec_stat = 2;
pub const graph_exec_stat_GRAPH_STAT_DONE: graph_exec_stat = 3;
pub const graph_exec_stat_GRAPH_STAT_ERROR: graph_exec_stat = 4;
pub type graph_exec_stat = ::std::os::raw::c_uint;
pub const device_policy_DEFAULT_POLICY: device_policy = 0;
pub const device_policy_LATENCY_POLICY: device_policy = 1;
pub const device_policy_LOW_POWER_POLICY: device_policy = 2;
pub type device_policy = ::std::os::raw::c_uint;
pub type context_t = *mut ::std::os::raw::c_void;
pub type graph_t = *mut ::std::os::raw::c_void;
pub type tensor_t = *mut ::std::os::raw::c_void;
pub type node_t = *mut ::std::os::raw::c_void;
pub type event_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: graph_t,
        arg2: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type log_print_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct options {
    pub num_thread: ::std::os::raw::c_int,
    pub cluster: ::std::os::raw::c_int,
    pub precision: ::std::os::raw::c_int,
    pub affinity: u64,
}
#[test]
fn bindgen_test_layout_options() {
    assert_eq!(
        ::std::mem::size_of::<options>(),
        24usize,
        concat!("Size of: ", stringify!(options))
    );
    assert_eq!(
        ::std::mem::align_of::<options>(),
        8usize,
        concat!("Alignment of ", stringify!(options))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<options>())).num_thread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(options),
            "::",
            stringify!(num_thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<options>())).cluster as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(options),
            "::",
            stringify!(cluster)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<options>())).precision as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(options),
            "::",
            stringify!(precision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<options>())).affinity as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(options),
            "::",
            stringify!(affinity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_info {
    pub name: *const ::std::os::raw::c_char,
    pub dev_name: *const ::std::os::raw::c_char,
    pub count: u32,
    pub min: u32,
    pub max: u32,
    pub total_time: u64,
    pub base: u32,
}
#[test]
fn bindgen_test_layout_perf_info() {
    assert_eq!(
        ::std::mem::size_of::<perf_info>(),
        48usize,
        concat!("Size of: ", stringify!(perf_info))
    );
    assert_eq!(
        ::std::mem::align_of::<perf_info>(),
        8usize,
        concat!("Alignment of ", stringify!(perf_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<perf_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(perf_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<perf_info>())).dev_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(perf_info),
            "::",
            stringify!(dev_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<perf_info>())).count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(perf_info),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<perf_info>())).min as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(perf_info),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<perf_info>())).max as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(perf_info),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<perf_info>())).total_time as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(perf_info),
            "::",
            stringify!(total_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<perf_info>())).base as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(perf_info),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct custom_kernel_tensor {
    pub dim: [::std::os::raw::c_int; 4usize],
    pub dim_num: ::std::os::raw::c_int,
    pub element_num: ::std::os::raw::c_int,
    pub element_size: ::std::os::raw::c_int,
    pub data_type: ::std::os::raw::c_int,
    pub dev_type: ::std::os::raw::c_int,
    pub layout_type: ::std::os::raw::c_int,
    pub quant_type: ::std::os::raw::c_int,
    pub scale: *mut f32,
    pub zero_point: *mut ::std::os::raw::c_int,
    pub quant_number: *mut ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_void,
    pub dev_mem: *mut ::std::os::raw::c_void,
    pub mapped_mem: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_custom_kernel_tensor() {
    assert_eq!(
        ::std::mem::size_of::<custom_kernel_tensor>(),
        96usize,
        concat!("Size of: ", stringify!(custom_kernel_tensor))
    );
    assert_eq!(
        ::std::mem::align_of::<custom_kernel_tensor>(),
        8usize,
        concat!("Alignment of ", stringify!(custom_kernel_tensor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_tensor>())).dim as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_tensor),
            "::",
            stringify!(dim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_tensor>())).dim_num as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_tensor),
            "::",
            stringify!(dim_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<custom_kernel_tensor>())).element_num as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_tensor),
            "::",
            stringify!(element_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<custom_kernel_tensor>())).element_size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_tensor),
            "::",
            stringify!(element_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_tensor>())).data_type as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_tensor),
            "::",
            stringify!(data_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_tensor>())).dev_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_tensor),
            "::",
            stringify!(dev_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<custom_kernel_tensor>())).layout_type as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_tensor),
            "::",
            stringify!(layout_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_tensor>())).quant_type as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_tensor),
            "::",
            stringify!(quant_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_tensor>())).scale as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_tensor),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_tensor>())).zero_point as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_tensor),
            "::",
            stringify!(zero_point)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<custom_kernel_tensor>())).quant_number as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_tensor),
            "::",
            stringify!(quant_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_tensor>())).data as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_tensor),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_tensor>())).dev_mem as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_tensor),
            "::",
            stringify!(dev_mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_tensor>())).mapped_mem as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_tensor),
            "::",
            stringify!(mapped_mem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct custom_kernel_ops {
    pub kernel_name: *const ::std::os::raw::c_char,
    pub op: *const ::std::os::raw::c_char,
    pub force: ::std::os::raw::c_int,
    pub kernel_param: *mut ::std::os::raw::c_void,
    pub kernel_param_size: ::std::os::raw::c_int,
    #[doc = " @brief generate output shape according to input shapes"]
    #[doc = "        if not implemented, set it to NULL."]
    #[doc = ""]
    #[doc = " @param [in]  ops: The point of custom defined kernel."]
    #[doc = " @param [in]  inputs[]:  pointer array to the shape of input tensors."]
    #[doc = "                         the shape has MAX_SHAPE_DIM_NUM elements,"]
    #[doc = "                         and element with value 0  means the end of the shape."]
    #[doc = " @param [in]  input_num: The number of input tensors."]
    #[doc = " @param [out] outputs[]: pointer array to the shape of output tensors."]
    #[doc = "                         the memory has been allocated already"]
    #[doc = " @param [in]  output_num: The number of output tensors"]
    #[doc = " @param [in]  layout: the graph layout is NHWC or NCHW"]
    #[doc = ""]
    #[doc = " @return 0: success, -1: fail."]
    pub infer_shape: ::std::option::Option<
        unsafe extern "C" fn(
            ops: *mut custom_kernel_ops,
            inputs: *mut *const ::std::os::raw::c_int,
            input_num: ::std::os::raw::c_int,
            outputs: *mut *mut ::std::os::raw::c_int,
            output_num: ::std::os::raw::c_int,
            layout: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " @brief Get the inplace input tensor index for an output tensor."]
    #[doc = ""]
    #[doc = " @param [in] ops: The point of custom defined kernel."]
    #[doc = " @param [in] output_idx: The index of custom defined kernel output."]
    #[doc = ""]
    #[doc = " @return the inplace input tensor index for an output tensor."]
    #[doc = "         if the output tensor is not an inplace one, return -1."]
    pub inplace_info: ::std::option::Option<
        unsafe extern "C" fn(
            ops: *mut custom_kernel_ops,
            output_idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " @brief Check if the kernel can work on the input and output shapes."]
    #[doc = ""]
    #[doc = " @param [in] ops: The point of custom defined kernel."]
    #[doc = " @param [in] inputs[]: The custom kernel tensors for input."]
    #[doc = " @param [in] input_num: The number of the input tensors."]
    #[doc = " @param [in] outputs[]: The custom kernel output tensor for output"]
    #[doc = " @param [in] output_num: The number of the output tensors."]
    #[doc = ""]
    #[doc = " @return 0 if the input and output are supported"]
    #[doc = "         otherwise, return -1."]
    #[doc = ""]
    #[doc = " notes: If not implemented, set it NULL, which means always return 0."]
    pub bind: ::std::option::Option<
        unsafe extern "C" fn(
            ops: *mut custom_kernel_ops,
            inputs: *mut *const custom_kernel_tensor,
            input_num: ::std::os::raw::c_int,
            outputs: *mut *const custom_kernel_tensor,
            output_num: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " @brief Prepare for run graph."]
    #[doc = "        dynamic_shape means it is not an abnormal case when input_num is zero."]
    #[doc = ""]
    #[doc = " @param [in] ops: The point of custom defined kernel."]
    #[doc = " @param [in] inputs[]: The custom defined kernel input tensor."]
    #[doc = " @param [in] input_num: The number of the custom defined kernel input tensor."]
    #[doc = " @param [in] outputs[]: The custom defined kernel output tensor."]
    #[doc = " @param [in] output_num: The number of the custom defined kernel output tensor."]
    #[doc = " @param [in] dynamic_shape: It is not an abnormal case when input_num is zero."]
    #[doc = ""]
    #[doc = " @return 0: success, -1: fail."]
    pub prerun: ::std::option::Option<
        unsafe extern "C" fn(
            ops: *mut custom_kernel_ops,
            inputs: *mut *mut custom_kernel_tensor,
            input_num: ::std::os::raw::c_int,
            outputs: *mut *mut custom_kernel_tensor,
            output_num: ::std::os::raw::c_int,
            dynamic_shape: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " @brief Reshape the graph."]
    #[doc = ""]
    #[doc = " @param [in] ops: The point of custom defined kernel."]
    #[doc = " @param [in] inputs[]: The custom defined kernel input tensor."]
    #[doc = " @param [in] input_num: The number of the custom defined kernel input tensor."]
    #[doc = " @param [in] outputs[]: The custom defined kernel output tensor."]
    #[doc = " @param [in] output_num: The number of the custom defined kernel output tensor."]
    #[doc = ""]
    #[doc = " @return 0: success, -1: fail."]
    #[doc = ""]
    #[doc = " notes: It will be called, when input shape changed."]
    #[doc = "        After prerun() has been called, need to reclaim and re-allocate run-time"]
    #[doc = "        resource depends on input shape."]
    pub reshape: ::std::option::Option<
        unsafe extern "C" fn(
            ops: *mut custom_kernel_ops,
            inputs: *mut *mut custom_kernel_tensor,
            input_num: ::std::os::raw::c_int,
            outputs: *mut *mut custom_kernel_tensor,
            output_num: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " @brief Run the graph."]
    #[doc = ""]
    #[doc = " @param [in] ops: The point of custom defined kernel."]
    #[doc = " @param [in] inputs[]: The custom defined kernel input tensor."]
    #[doc = " @param [in] input_num: The number of the custom defined kernel input tensor."]
    #[doc = " @param [in] outputs[]: The custom defined kernel output tensor."]
    #[doc = " @param [in] output_num: The number of the custom defined kernel output tensor."]
    #[doc = ""]
    #[doc = " @return 0: success, -1: fail."]
    pub run: ::std::option::Option<
        unsafe extern "C" fn(
            ops: *mut custom_kernel_ops,
            inputs: *mut *mut custom_kernel_tensor,
            input_num: ::std::os::raw::c_int,
            outputs: *mut *mut custom_kernel_tensor,
            output_num: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " @brief Pause the graph and release the resources used when the graph is running."]
    #[doc = ""]
    #[doc = " @param [in] ops: The point of custom defined kernel."]
    #[doc = " @param [in] inputs[]: The custom defined kernel input tensor."]
    #[doc = " @param [in] input_num: The number of the custom defined kernel input tensor."]
    #[doc = " @param [in] outputs[]: The custom defined kernel output tensor."]
    #[doc = " @param [in] output_num: The number of the custom defined kernel output tensor."]
    #[doc = ""]
    #[doc = " @return 0: success, -1: fail."]
    pub postrun: ::std::option::Option<
        unsafe extern "C" fn(
            ops: *mut custom_kernel_ops,
            inputs: *mut *mut custom_kernel_tensor,
            input_num: ::std::os::raw::c_int,
            outputs: *mut *mut custom_kernel_tensor,
            output_num: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " @brief Free the resource allocated this ops implementation."]
    #[doc = ""]
    #[doc = " @param [in] ops: The point of custom defined kernel."]
    #[doc = ""]
    #[doc = " @return None."]
    pub release: ::std::option::Option<unsafe extern "C" fn(ops: *mut custom_kernel_ops)>,
}
#[test]
fn bindgen_test_layout_custom_kernel_ops() {
    assert_eq!(
        ::std::mem::size_of::<custom_kernel_ops>(),
        104usize,
        concat!("Size of: ", stringify!(custom_kernel_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<custom_kernel_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(custom_kernel_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_ops>())).kernel_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_ops),
            "::",
            stringify!(kernel_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_ops>())).op as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_ops),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_ops>())).force as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_ops),
            "::",
            stringify!(force)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_ops>())).kernel_param as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_ops),
            "::",
            stringify!(kernel_param)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<custom_kernel_ops>())).kernel_param_size as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_ops),
            "::",
            stringify!(kernel_param_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_ops>())).infer_shape as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_ops),
            "::",
            stringify!(infer_shape)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_ops>())).inplace_info as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_ops),
            "::",
            stringify!(inplace_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_ops>())).bind as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_ops),
            "::",
            stringify!(bind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_ops>())).prerun as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_ops),
            "::",
            stringify!(prerun)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_ops>())).reshape as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_ops),
            "::",
            stringify!(reshape)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_ops>())).run as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_ops),
            "::",
            stringify!(run)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_ops>())).postrun as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_ops),
            "::",
            stringify!(postrun)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<custom_kernel_ops>())).release as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_kernel_ops),
            "::",
            stringify!(release)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize the tengine, only can be called once."]
    #[doc = ""]
    #[doc = " @return 0: Success, -1: Fail."]
    pub fn init_tengine() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Release the tengine, only can be called once."]
    #[doc = ""]
    #[doc = " @return none."]
    pub fn release_tengine();
}
extern "C" {
    #[doc = " @brief Get the version of the tengine."]
    #[doc = ""]
    #[doc = " @return const char * of version string."]
    pub fn get_tengine_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Check the run-time library supports the verson."]
    #[doc = "        app developer should call get_tengine_version() to save the version used"]
    #[doc = "        during developping."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "        The app knows exactly that it can work on a tengine version, and it can"]
    #[doc = "        check run-time tengine library supports that version."]
    #[doc = ""]
    #[doc = " @param [in] version: A c string returned by get_tengine_version()"]
    #[doc = " @return 1: support, 0: not support."]
    pub fn request_tengine_version(version: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Create the run-time graph for execution from a saved model."]
    #[doc = "        If model format is NULL, an empty graph handle will be returned."]
    #[doc = ""]
    #[doc = " @param [in] context: The context the graph will run inside;"]
    #[doc = "                   could be NULL and the graph is created in a private context."]
    #[doc = ""]
    #[doc = " @param [in] model_format: The model format type,such as \"caffe\",\"tengine\""]
    #[doc = " @param [in] file_name:  The name of model file."]
    #[doc = ""]
    #[doc = " @return  The graph handler or NULL if failed."]
    pub fn create_graph(
        context: context_t,
        model_format: *const ::std::os::raw::c_char,
        file_name: *const ::std::os::raw::c_char,
        ...
    ) -> graph_t;
}
extern "C" {
    #[doc = " @brief Set the layout type of the graph"]
    #[doc = "        the default layout of graph is NCHW"]
    #[doc = " @param [in] graph, the graph handle"]
    #[doc = " @param [in] layout_type, the layout type NCHW or NHWC"]
    #[doc = ""]
    #[doc = " @return 0 success, or -1 fail"]
    pub fn set_graph_layout(
        graph: graph_t,
        layout_type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief designate the input nodes of the graph"]
    #[doc = ""]
    #[doc = " @param [in] graph: the graph handle"]
    #[doc = " @param [in] input_nodes: the node name list of input nodes"]
    #[doc = " @param [in] input_number: the number of input_nodes"]
    #[doc = ""]
    #[doc = " @note  if using the default input nodes of a graph, this call can be skipped"]
    pub fn set_graph_input_node(
        graph: graph_t,
        input_nodes: *mut *const ::std::os::raw::c_char,
        input_number: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief designate the output nodes of the graph"]
    #[doc = ""]
    #[doc = " @param [in] graph: the graph handle"]
    #[doc = " @param [in] output_nodes: the node name list of output nodes"]
    #[doc = " @param [in] output_number: the number of output_nodes"]
    #[doc = ""]
    #[doc = " @note  if using the default output nodes of a graph, this call can be skipped"]
    pub fn set_graph_output_node(
        graph: graph_t,
        output_nodes: *mut *const ::std::os::raw::c_char,
        output_number: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Destory the runtime graph and release allocated resource."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @return 0: Success, -1: Fail."]
    pub fn destroy_graph(graph: graph_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the number of input node of the graph."]
    #[doc = ""]
    #[doc = "  @param [in] graph The graph handle."]
    #[doc = "  @return <0 Fail, >0 the input node number."]
    pub fn get_graph_input_node_number(graph: graph_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the node handle of #idx of input node of the graph."]
    #[doc = ""]
    #[doc = " @param [in] graph The graph handle."]
    #[doc = " @param [in] idx The input node index,starting from zero."]
    #[doc = ""]
    #[doc = " @return The node name or NULL on error."]
    pub fn get_graph_input_node(graph: graph_t, idx: ::std::os::raw::c_int) -> node_t;
}
extern "C" {
    #[doc = " @brief Get the number of output node of the graph."]
    #[doc = ""]
    #[doc = "  @param [in] graph The graph handle."]
    #[doc = ""]
    #[doc = "  @return <0 error, >0 the input node number."]
    pub fn get_graph_output_node_number(graph: graph_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the node handle #idx of a graph output node."]
    #[doc = ""]
    #[doc = " @param [in] graph The graph handle."]
    #[doc = " @param [in] idx The input node index, starting from zero."]
    #[doc = ""]
    #[doc = " @return The node name or NULL on error."]
    pub fn get_graph_output_node(graph: graph_t, idx: ::std::os::raw::c_int) -> node_t;
}
extern "C" {
    #[doc = " @brief Get a tensor handle of a graph output node."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] output_node_idx: The output node index."]
    #[doc = " @param [in] tensor_idx: The output tensor index of the output node."]
    #[doc = ""]
    #[doc = " @return The tensor handle or NULL on error."]
    #[doc = ""]
    pub fn get_graph_output_tensor(
        graph: graph_t,
        output_node_idx: ::std::os::raw::c_int,
        tensor_idx: ::std::os::raw::c_int,
    ) -> tensor_t;
}
extern "C" {
    #[doc = " @brief Get tensor handle of one graph input tensor."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] input_node_idx: The input node index, starting from zero."]
    #[doc = " @param [in] tensor_idx: The output tensor index of the input node, starting from zero."]
    #[doc = ""]
    #[doc = " @return The tensor handle or NULL on error."]
    pub fn get_graph_input_tensor(
        graph: graph_t,
        input_node_idx: ::std::os::raw::c_int,
        tensor_idx: ::std::os::raw::c_int,
    ) -> tensor_t;
}
extern "C" {
    #[doc = " node operate set ****************************/"]
    #[doc = " @brief Create a node for the graph."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] node_name: The name of the node."]
    #[doc = " @param [in] op_name: The name of the operate."]
    #[doc = ""]
    #[doc = " @return The node handle or NULL on error."]
    pub fn create_graph_node(
        graph: graph_t,
        node_name: *const ::std::os::raw::c_char,
        op_name: *const ::std::os::raw::c_char,
    ) -> node_t;
}
extern "C" {
    #[doc = " @brief  Get the node handle of the graph."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] node_name: The name of the node."]
    #[doc = ""]
    #[doc = " @return The node handle or NULL on error."]
    pub fn get_graph_node(graph: graph_t, node_name: *const ::std::os::raw::c_char) -> node_t;
}
extern "C" {
    #[doc = " @brief  Get the node handle of the graph."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] idx: The index of the node."]
    #[doc = ""]
    #[doc = " @return The node handle or NULL on error."]
    pub fn get_graph_node_by_idx(graph: graph_t, idx: ::std::os::raw::c_int) -> node_t;
}
extern "C" {
    #[doc = " @brief  Get the node handle of the graph."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = ""]
    #[doc = " @return The quantities of all nodes."]
    pub fn get_graph_node_num(graph: graph_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the node name."]
    #[doc = ""]
    #[doc = " @param [in] node: The node handle."]
    #[doc = ""]
    #[doc = " @return The node name, NULL on error."]
    pub fn get_node_name(node: node_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the node op."]
    #[doc = ""]
    #[doc = " @param [in] node: The node handle."]
    #[doc = ""]
    #[doc = " @return The op name, NULL on error."]
    pub fn get_node_op(node: node_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief  Release the node handle."]
    #[doc = ""]
    #[doc = " @param  [in] node: The node handle."]
    #[doc = ""]
    #[doc = " @return None."]
    pub fn release_graph_node(node: node_t);
}
extern "C" {
    #[doc = " @brief Get the input tensor handle of a node."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] node_name: The node name."]
    #[doc = " @param [in] input_idx: The index of the input tensor."]
    #[doc = " @return The tensor name or NULL on error."]
    #[doc = ""]
    pub fn get_node_input_tensor(node: node_t, input_idx: ::std::os::raw::c_int) -> tensor_t;
}
extern "C" {
    #[doc = " @brief Get the output tensor handle of a node."]
    #[doc = ""]
    #[doc = " @param [in] node: The node handle."]
    #[doc = " @param [in] output_idx: The index of the output tensor."]
    #[doc = ""]
    #[doc = " @return The tensor handle or NULL on error."]
    #[doc = ""]
    pub fn get_node_output_tensor(node: node_t, output_idx: ::std::os::raw::c_int) -> tensor_t;
}
extern "C" {
    #[doc = " @brief Set a node's the #idx input tensor."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] input_idx: The index of the input tensor."]
    #[doc = " @param [in] tesnor: The tensor handle."]
    #[doc = ""]
    #[doc = " @return 0 on success or -1 on error."]
    #[doc = ""]
    pub fn set_node_input_tensor(
        node: node_t,
        input_idx: ::std::os::raw::c_int,
        tensor: tensor_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set a node's the #idx output tensor."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] output_idx: The index of the output tensor."]
    #[doc = " @param [in] tensor: The tensor handle."]
    #[doc = " @param [in] tensor_type: The tensor type: VAR/CONST/INPUT/DEP"]
    #[doc = ""]
    #[doc = "  @return 0 on success or -1 on error."]
    #[doc = ""]
    pub fn set_node_output_tensor(
        node: node_t,
        output_idx: ::std::os::raw::c_int,
        tensor: tensor_t,
        tensor_type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the output tensor number of a node."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] node: The node hanle."]
    #[doc = ""]
    #[doc = " @return >=1 the number of output tensor,"]
    #[doc = "         -1 on error."]
    #[doc = ""]
    pub fn get_node_output_number(node: node_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the input tensor number of a node."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] node: The node hanle."]
    #[doc = ""]
    #[doc = " @return >=1 the number of output tensor,"]
    #[doc = "         -1 on error."]
    #[doc = ""]
    pub fn get_node_input_number(node: node_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add an attribute to a node."]
    #[doc = ""]
    #[doc = " @param [in] node: The target node handle."]
    #[doc = " @param [in] attr_name: The name of the attribute to be added."]
    #[doc = " @param [in] type_name: The name of the std::type_info of the type,"]
    #[doc = "                       can be set to NULL to skip type match checking."]
    #[doc = " @param [in] size: The size of the attribute"]
    #[doc = ""]
    #[doc = " @return 0: Successfully,"]
    #[doc = "         -1: Failed."]
    pub fn add_node_attr(
        node: node_t,
        attr_name: *const ::std::os::raw::c_char,
        type_name: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the attribute value (int) of a node"]
    #[doc = "        backended by get_node_attr_generic()."]
    #[doc = ""]
    #[doc = " @param [in] node: The target node."]
    #[doc = " @param [in] attr_name: The name of the attribute to be retrieval."]
    #[doc = " @param [out] attr_val: Pointer to the int val to be saved."]
    #[doc = ""]
    #[doc = " @return 0: Retrieval value Successfully,"]
    #[doc = "         -1: Failed, the name does not exist or the type mismatch."]
    #[doc = ""]
    pub fn get_node_attr_int(
        node: node_t,
        attr_name: *const ::std::os::raw::c_char,
        attr_val: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the attribute value (float) of a node"]
    #[doc = "        backended by get_node_attr_generic()."]
    #[doc = ""]
    #[doc = " @param [in] node: The target node."]
    #[doc = " @param [in] attr_name: The name of the attribute to be retrieval."]
    #[doc = " @param [out] attr_val: Pointer to the float val to be saved."]
    #[doc = ""]
    #[doc = " @return 0: Retrieval value Successfully,"]
    #[doc = "         -1: Failed, the name does not exist or the type mismatch."]
    pub fn get_node_attr_float(
        node: node_t,
        attr_name: *const ::std::os::raw::c_char,
        attr_val: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the attribute value (pointer) of a node"]
    #[doc = "        backended by get_node_attr_generic()."]
    #[doc = ""]
    #[doc = " @param [in] node: The target node."]
    #[doc = " @param [in] attr_name: The name of the attribute to be retrieval."]
    #[doc = " @param [out] attr_val: Pointer to the pointer val to be saved."]
    #[doc = ""]
    #[doc = " @return  0: Retrieval value Successfully,"]
    #[doc = "         -1: Failed, the name does not exist or the type mismatch."]
    pub fn get_node_attr_pointer(
        node: node_t,
        attr_name: *const ::std::os::raw::c_char,
        attr_val: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the attribute value of a node, the data type is indicated by type_info."]
    #[doc = ""]
    #[doc = " @param [in] node: The target node."]
    #[doc = " @param [in] attr_name: The name of the attribute to be retrieval."]
    #[doc = " @param [in] type_info: The pointer to the std::type_info of expected type"]
    #[doc = "                   can be set to NULL to skip type match checking."]
    #[doc = " @param [out] buf: The pointer to the buffer to save val."]
    #[doc = " @param [in] size: The buffer size."]
    #[doc = ""]
    #[doc = " @return  0: Retrieval value Successfully,"]
    #[doc = "         -1: Failed; The name does not exist or the type mismatch."]
    #[doc = ""]
    pub fn get_node_attr_generic(
        node: node_t,
        attr_name: *const ::std::os::raw::c_char,
        type_name: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the attribute value (int) of a node"]
    #[doc = "        backended by set_node_attr_generic()."]
    #[doc = ""]
    #[doc = " @param [in] node: The target node."]
    #[doc = " @param [in] attr_name: The name of the attribute to be retrieval."]
    #[doc = " @param [in] attr_val: The pointer to the int val to be set."]
    #[doc = ""]
    #[doc = " @return  0: Retrieval value Successfully;"]
    #[doc = "         -1: Failed, The name does not exist or the type mismatch."]
    #[doc = ""]
    pub fn set_node_attr_int(
        node: node_t,
        attr_name: *const ::std::os::raw::c_char,
        attr_val: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the attribute value (float) of a node"]
    #[doc = "        backended by set_node_attr_generic()."]
    #[doc = ""]
    #[doc = " @param [in] node: The target node."]
    #[doc = " @param [in] attr_name: The name of the attribute to be retrieval."]
    #[doc = " @param [in] attr_val: The pointer to the float val to be set."]
    #[doc = ""]
    #[doc = " @return  0: Retrieval value Successfully."]
    #[doc = "         -1: Failed, The name does not exist or the type mismatch."]
    #[doc = ""]
    pub fn set_node_attr_float(
        node: node_t,
        attr_name: *const ::std::os::raw::c_char,
        attr_val: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the attribute value (pointer) of a node"]
    #[doc = "        backended by set_node_attr_generic()."]
    #[doc = ""]
    #[doc = " @param [in] node: The target node."]
    #[doc = " @param [in] attr_name: The name of the attribute to be retrieval."]
    #[doc = " @param [in] attr_val: The pointer to the pointer val to be set."]
    #[doc = ""]
    #[doc = " @return  0: Retrieval value Successfully"]
    #[doc = "         -1: Failed, The name does not exist or the type mismatch."]
    #[doc = ""]
    pub fn set_node_attr_pointer(
        node: node_t,
        attr_name: *const ::std::os::raw::c_char,
        attr_val: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the attribute value of a node, the data type is indicated by type_info."]
    #[doc = ""]
    #[doc = " @param [in] node: The target node."]
    #[doc = " @param [in] attr_name: The name of the attribute to be retrieval."]
    #[doc = " @param [in] type_info: The pointer to the std::type_info of wanted type,"]
    #[doc = "                   can be set to NULL to skip type match checking."]
    #[doc = " @param [in] buf: The pointer to the buffer to hold val."]
    #[doc = " @param [in] size: The buffer size."]
    #[doc = ""]
    #[doc = " @return  0: Retrieval value Successfully."]
    #[doc = "         -1: Failed, The name does not exist or the type mismatch."]
    #[doc = ""]
    pub fn set_node_attr_generic(
        node: node_t,
        attr_name: *const ::std::os::raw::c_char,
        type_name: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set customer kernel of a node, on a specific device,"]
    #[doc = "        the operate in kernel_ops must be the same as node's operate."]
    #[doc = ""]
    #[doc = " @param [in] node: The node handle."]
    #[doc = " @param [in] device: The kernel works for which device. NULL means for default device."]
    #[doc = " @param [in] kernel_ops: The custom implemented kernel operates."]
    #[doc = ""]
    #[doc = " @return 0: Success, -1: Fail."]
    pub fn set_custom_kernel(
        node: node_t,
        dev_name: *const ::std::os::raw::c_char,
        kernel_ops: *mut custom_kernel_ops,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Remove customer kernel of a node, on a specific device."]
    #[doc = ""]
    #[doc = " @param [in] node: The node handle."]
    #[doc = " @param [in] device: The kernel works for which device. NULL means for default device."]
    #[doc = ""]
    #[doc = " @return 0: Success, -1: Fail."]
    pub fn remove_custom_kernel(
        node: node_t,
        dev_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief create a tensor handle by tensor name."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle"]
    #[doc = " @param [in] tensor_name: Tensor name."]
    #[doc = " @param [in] data_type:  the data type."]
    #[doc = ""]
    #[doc = " @return The tensor handle or NULL on error."]
    #[doc = ""]
    pub fn create_graph_tensor(
        graph: graph_t,
        tensor_name: *const ::std::os::raw::c_char,
        data_type: ::std::os::raw::c_int,
    ) -> tensor_t;
}
extern "C" {
    #[doc = " @brief Get a tensor handle by tensor name."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] tensor_name: Tensor name."]
    #[doc = ""]
    #[doc = " @return The tensor handle or NULL on error."]
    #[doc = ""]
    pub fn get_graph_tensor(graph: graph_t, tensor_name: *const ::std::os::raw::c_char)
        -> tensor_t;
}
extern "C" {
    #[doc = " @brief  Get the name of the tensor handle."]
    #[doc = ""]
    #[doc = " @param [in] tensor: the tensor handle."]
    #[doc = ""]
    #[doc = " @return A c string."]
    #[doc = ""]
    pub fn get_tensor_name(tensor: tensor_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Release the tensor handle."]
    #[doc = ""]
    #[doc = " @param [in] tensor: The tensor handle."]
    #[doc = ""]
    #[doc = " @return None."]
    pub fn release_graph_tensor(tensor: tensor_t);
}
extern "C" {
    #[doc = " @brief Get the shape of tensor."]
    #[doc = ""]
    #[doc = " @param [in] tensor: The tensor handle."]
    #[doc = " @param [out] dims: An int array to get the returned shape."]
    #[doc = " @param [in] dim_number: The array size."]
    #[doc = " @return >=1 the valid dim number, or -1 Fail."]
    #[doc = ""]
    pub fn get_tensor_shape(
        tensor: tensor_t,
        dims: *mut ::std::os::raw::c_int,
        dim_number: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the shape of tensor."]
    #[doc = ""]
    #[doc = " @param [in] tensor: The tensor handle."]
    #[doc = " @param [in] dims: An int array to represent shape."]
    #[doc = " @param [in] dim_number: The array size."]
    #[doc = " @return 0: Success; -1: Fail."]
    #[doc = ""]
    pub fn set_tensor_shape(
        tensor: tensor_t,
        dims: *const ::std::os::raw::c_int,
        dim_number: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the byte size of a tensor should occupy."]
    #[doc = ""]
    #[doc = " @param [in] tensor: The tensor handle."]
    #[doc = ""]
    #[doc = " @return <0: Error; >=0: Tensor size."]
    #[doc = " @note   If return 0, it means the shape of the tensor is not set yet."]
    pub fn get_tensor_buffer_size(tensor: tensor_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the buffer of the tensor."]
    #[doc = "    A tensor may deny to expose its internal buffer, so that get_tensor_buffer()"]
    #[doc = "    will fail but get_tensor_buffer_size()/set_tensor_data() succeed."]
    #[doc = ""]
    #[doc = " @param [in] tensor: The tensor handle."]
    #[doc = " @return The buffer address. if no buffer allocated return NULL."]
    pub fn get_tensor_buffer(tensor: tensor_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Set the buffer of the tensor."]
    #[doc = "    A tensor may deny to change its internal buffer setting."]
    #[doc = ""]
    #[doc = " @param [in] tensor: The tensor handle."]
    #[doc = " @param [in] buffer: The buffer address."]
    #[doc = " @param [in] buffer_size: The buffer_size."]
    #[doc = ""]
    #[doc = " @return 0: Success; -1: Fail."]
    #[doc = " @note  The buffer is still managed by caller."]
    pub fn set_tensor_buffer(
        tensor: tensor_t,
        buffer: *mut ::std::os::raw::c_void,
        buffer_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Copy tensor data to the output data buffer."]
    #[doc = " @param [in] tensor: The tensor handle."]
    #[doc = " @param [out] output_data: The output data buffer."]
    #[doc = ""]
    #[doc = " @param [in] data_size: the output buffer size."]
    #[doc = " @return 0: Success; or -1: Fail."]
    #[doc = ""]
    pub fn get_tensor_data(
        tensor: tensor_t,
        output_data: *mut ::std::os::raw::c_void,
        data_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Copy the data to tensor buffer."]
    #[doc = ""]
    #[doc = " @param [in] tensor: The tensor handle."]
    #[doc = " @param [in] input_data: The input data."]
    #[doc = " @param [in] data_size: The input data size."]
    #[doc = ""]
    #[doc = " @return 0: Success; -1: Fail."]
    #[doc = ""]
    pub fn set_tensor_data(
        tensor: tensor_t,
        input_data: *const ::std::os::raw::c_void,
        data_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the data type of the tensor."]
    #[doc = ""]
    #[doc = " @param [in] tensor: The tensor handle."]
    #[doc = ""]
    #[doc = " @return The tensor type, see TENGINE_DT_FP32 etc, -1 on error."]
    pub fn get_tensor_data_type(tensor: tensor_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the data type of the tensor."]
    #[doc = ""]
    #[doc = " @param [in] tensor: The tensor handle."]
    #[doc = " @param [in] data_type: The data type. see TENGINE_DT_FP32 etc."]
    #[doc = ""]
    #[doc = " @return 0 on sucess, -1 on error."]
    pub fn set_tensor_data_type(
        tensor: tensor_t,
        data_type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the data layout of the tensor."]
    #[doc = ""]
    #[doc = " @param [in] tensor: The tensor handle."]
    #[doc = ""]
    #[doc = " @return The tensor type, 0 : nchw, 1 : nhwc."]
    pub fn get_tensor_layout(tensor: tensor_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the data layout of the tensor."]
    #[doc = ""]
    #[doc = " @param [in] tensor: The tensor handle."]
    #[doc = " @param [in] layout: The data layout, 0 : nchw, 1 : nhwc."]
    #[doc = ""]
    #[doc = " @return 0 on sucess, -1 on error."]
    pub fn set_tensor_layout(
        tensor: tensor_t,
        layout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set tensor quant parameters"]
    #[doc = ""]
    #[doc = " @param [in] tensor: The tensor handle."]
    #[doc = " @param [in] scale:  The scale array address."]
    #[doc = " @param [in] zero point: The zero point address."]
    #[doc = " @param [in] number:  The element number of array."]
    #[doc = ""]
    #[doc = " @return 0 on sucess, -1 on error."]
    pub fn set_tensor_quant_param(
        tensor: tensor_t,
        scale: *const f32,
        zero_point: *const ::std::os::raw::c_int,
        number: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get tensor quant parameters."]
    #[doc = ""]
    #[doc = " @param [in] tensor: The tensor handle."]
    #[doc = " @param [in] scale:  The scale array address."]
    #[doc = " @param [in] zero point: The zero point address."]
    #[doc = " @param [in] number:  The element number of array."]
    #[doc = ""]
    #[doc = " @return 0 on sucess, -1 on error."]
    pub fn get_tensor_quant_param(
        tensor: tensor_t,
        scale: *mut f32,
        zero_point: *mut ::std::os::raw::c_int,
        number: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The interface to get possible cpu mask bits, when specified cluster of cpu,"]
    #[doc = "        function will return the mask bits of the cluster."]
    #[doc = ""]
    #[doc = " @param [in] cluster: The be queried cluster."]
    #[doc = ""]
    #[doc = " @return affinity mask."]
    pub fn get_cluster_affinity_mask(cluster: ::std::os::raw::c_int) -> size_t;
}
extern "C" {
    #[doc = " @brief The interface to set cluster and threads count will used."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] cluster: The wanted cluster of all cpu clusters."]
    #[doc = " @param [in] threads: The threads count of graph will used to run."]
    #[doc = ""]
    #[doc = " @return 0: Success, -1: Fail."]
    pub fn set_graph_thread(
        graph: graph_t,
        cluster: ::std::os::raw::c_int,
        threads: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The interface to directly set used cpu mask."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] cpu_mask: The mask bits of graph will used to run."]
    #[doc = ""]
    #[doc = " @return 0: Success, -1: Fail."]
    pub fn set_graph_thread_mask(graph: graph_t, cpu_mask: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The interface to set some proprietary attribute items for graph."]
    #[doc = "        The backend device to run the graph may use the attribute item."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] attr_name: The attribute name."]
    #[doc = " @param [in] buf: The buffer to hold data."]
    #[doc = " @param [in] size: The buffer size."]
    #[doc = ""]
    #[doc = " @return 0: Success, -1: Fail."]
    pub fn set_graph_attr(
        graph: graph_t,
        attr_name: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The interface to get some proprietary config items for graph."]
    #[doc = "        It is probabaly the config will be passed to the DLA driver."]
    #[doc = " @param [in] graph: the graph handle."]
    #[doc = " @param [in] name: The attribute name."]
    #[doc = " @param [in] buf: The buffer to hold data."]
    #[doc = " @param [in] size: The buffer size."]
    #[doc = ""]
    #[doc = " @return 0: Success, -1: Fail."]
    #[doc = ""]
    pub fn get_graph_attr(
        graph: graph_t,
        attr_name: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Initialize resource for graph execution, and set cluster and threads count will used."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] cluster: The wanted cluster of all cpu clusters."]
    #[doc = " @param [in] threads: The threads count of graph will used to run."]
    #[doc = ""]
    #[doc = " @return 0: Success, -1: Fail."]
    #[doc = ""]
    pub fn prerun_graph_multithread(graph: graph_t, opt: options) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Initialize resource for graph execution."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = ""]
    #[doc = " @return 0: Success, -1: Fail."]
    #[doc = ""]
    pub fn prerun_graph(graph: graph_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Execute graph."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] block: Blocking or nonlocking."]
    #[doc = " @return 0: Success, -1: Fail."]
    #[doc = " @note  If block is 0, need to call wait_graph to get result or set GRAPH_DONE event hook."]
    #[doc = ""]
    pub fn run_graph(graph: graph_t, block: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Wait graph execution done."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] try_wait: If set, just check status and return."]
    #[doc = " @return  1: Graph is done."]
    #[doc = "          0: Try again."]
    #[doc = ""]
    pub fn wait_graph(graph: graph_t, try_wait: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Release the resource for graph execution."]
    #[doc = " @param [in] graph: graph handle."]
    #[doc = ""]
    #[doc = " @return 0: Success, -1: Fail."]
    pub fn postrun_graph(graph: graph_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the status of graph execution."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = ""]
    #[doc = " @return status"]
    pub fn get_graph_exec_status(graph: graph_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the event hook for graph execution."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] event: The event to be hooked."]
    #[doc = " @param [in] cb_func: The callback funtion."]
    #[doc = " @param [in] cb_arg: The argument will be passed to callback function."]
    #[doc = " @return 0: Success, -1: Fail."]
    #[doc = ""]
    pub fn set_graph_event_hook(
        graph: graph_t,
        event: ::std::os::raw::c_int,
        cb_func: event_handler_t,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @set The default device."]
    #[doc = ""]
    #[doc = " @param [in] device: The device name."]
    #[doc = " @return 0: valid, -1: invalid."]
    #[doc = ""]
    pub fn set_default_device(device: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the device to execution a graph."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    #[doc = " @param [in] dev_name: The device name to run the node."]
    #[doc = ""]
    #[doc = " @return  =0: Bind success."]
    #[doc = "          <0: error."]
    #[doc = ""]
    pub fn set_graph_device(
        graph: graph_t,
        dev_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief get the device the node runs on"]
    #[doc = ""]
    #[doc = " @param [in] node: the node handle"]
    #[doc = ""]
    #[doc = " @return the device name or NULL if no device assigned yet"]
    pub fn get_node_device(node: node_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the default name of device."]
    #[doc = ""]
    #[doc = " @return The name of the default device."]
    pub fn get_default_device() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Create one execution context with name."]
    #[doc = ""]
    #[doc = " @param [in] context_name: The name of the created context."]
    #[doc = " @param [in] empty_context: No device is assigned with this context"]
    #[doc = "                            otherwise, all proved devices will be added into the context."]
    #[doc = ""]
    #[doc = " @return Execution context handle."]
    #[doc = "         If create Failed, return NULL."]
    pub fn create_context(
        context_name: *const ::std::os::raw::c_char,
        empty_context: ::std::os::raw::c_int,
    ) -> context_t;
}
extern "C" {
    #[doc = " @brief Destory and reclaim the resource related with the context."]
    #[doc = ""]
    #[doc = " @param [in] context: The context handle."]
    pub fn destroy_context(context: context_t);
}
extern "C" {
    #[doc = " @brief Get the device number assigned to a context."]
    #[doc = ""]
    #[doc = " @param [in] context: The context handle."]
    #[doc = ""]
    #[doc = " @return The number of devices inside the context."]
    pub fn get_context_device_number(context: context_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @brief Add a device into one context."]
    #[doc = ""]
    #[doc = "  @param [in] context: The context handle."]
    #[doc = "  @param [in] dev_name: The device name."]
    #[doc = ""]
    #[doc = "  @return 0: Success, -1: Fail."]
    pub fn add_context_device(
        context: context_t,
        dev_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @brief Remove a device from one context."]
    #[doc = ""]
    #[doc = "  @param [in] context: The context handle."]
    #[doc = "  @param [in] dev_name: The device name."]
    #[doc = ""]
    #[doc = "  @return 0: Success, -1: Fail."]
    pub fn remove_context_device(
        context: context_t,
        dev_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set attribute item of a context."]
    #[doc = ""]
    #[doc = " @param [in] context: The context handle."]
    #[doc = " @param [in] attr_name: The attribute item name."]
    #[doc = " @param [in] val: The buffer to hold the data to set."]
    #[doc = " @param [in] size: The buffer size."]
    #[doc = " @return 0: Success, -1: Fail."]
    pub fn set_context_attr(
        context: context_t,
        attr_name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_void,
        val_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the attribute item of a context."]
    #[doc = ""]
    #[doc = " @param [in] context: The context handle."]
    #[doc = " @param [in] attr_name: The attribute item name."]
    #[doc = " @param [out] val: The buffer to hold the data."]
    #[doc = " @param [in] size: The buffer size."]
    #[doc = " @return 0: Succuess, -1: Fail."]
    pub fn get_context_attr(
        context: context_t,
        attr_name: *const ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_void,
        val_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief return the error number"]
    #[doc = "        list of the symbolic error name follows glibc definitions"]
    #[doc = ""]
    #[doc = " @return the last error set in library"]
    #[doc = ""]
    #[doc = " @note It is MT-safe"]
    pub fn get_tengine_errno() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief return and clear the error number"]
    #[doc = "        list of the symbolic error name follows glibc definitions"]
    #[doc = ""]
    #[doc = " @return the last error set in library"]
    #[doc = ""]
    #[doc = " @note It is MT-safe"]
    pub fn clr_tengine_errno() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the logger level."]
    #[doc = ""]
    #[doc = " @param [in] level: The log level."]
    pub fn set_log_level(level: log_level);
}
extern "C" {
    #[doc = " @brief set the print function of log."]
    #[doc = ""]
    #[doc = " @param [in] func: The print function."]
    #[doc = ""]
    #[doc = " @return None."]
    #[doc = ""]
    #[doc = " @note  default log output is stdout"]
    pub fn set_log_output(func: log_print_t);
}
extern "C" {
    #[doc = " @brief Dump the run-time graph."]
    #[doc = "        If the graph is dumpped after prerun(), it will dump the optimized graph instead of the origin one."]
    #[doc = ""]
    #[doc = " @param [in] graph: The graph handle."]
    pub fn dump_graph(graph: graph_t);
}
extern "C" {
    #[doc = " Plug-in operate set *******************/"]
    #[doc = " @brief Load one plugin from disk, and execute the init function."]
    #[doc = ""]
    #[doc = " @param [in] plugin_name: Plugin name."]
    #[doc = " @param [in] fname: Plugin file name."]
    #[doc = " @param [in] init_func_name: The name of the init function."]
    #[doc = ""]
    #[doc = " @return 0: Plugin loaded and inited Success,"]
    #[doc = "      -1: Fail"]
    pub fn load_tengine_plugin(
        plugin_name: *const ::std::os::raw::c_char,
        fname: *const ::std::os::raw::c_char,
        init_func_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Unload one plugin and call the release function."]
    #[doc = ""]
    #[doc = " @param [in] plugin_name: The name of plugin."]
    #[doc = " @param [in] rel_func_name: The release function name."]
    #[doc = ""]
    #[doc = " @return  0: Success;"]
    #[doc = "      -1: Fail."]
    pub fn unload_tengine_plugin(
        plugin_name: *const ::std::os::raw::c_char,
        rel_func_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the number of loaded plugin."]
    #[doc = ""]
    #[doc = " @return The plugin number."]
    pub fn get_tengine_plugin_number() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the name of #idx plugin."]
    #[doc = ""]
    #[doc = " @param [in] idx: The index of loaded plugin."]
    #[doc = ""]
    #[doc = " @return The name of plugin."]
    pub fn get_tengine_plugin_name(idx: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_tengine_hcl_version() -> *const ::std::os::raw::c_char;
}
